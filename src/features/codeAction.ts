import {
    CodeAction,
    CodeActionKind,
    CodeActionParams,
    Command,
    TextEdit,
    WorkspaceEdit
} from 'vscode-languageserver/node';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { Logger } from '../utils/logger';
import { parseDocumentSymbols, getSymbolContainingPosition } from '../utils/parser';

/**
 * Handles code action requests.
 * Provides Quick Fixes for diagnostics generated by the validator.
 *
 * @param params The code action parameters.
 * @param document The text document.
 * @returns An array of CodeActions or Commands.
 */
export function onCodeAction(
    params: CodeActionParams,
    document: TextDocument
): (Command | CodeAction)[] {
    Logger.log('Code actions requested for ' + document.uri);
    const diagnostics = params.context.diagnostics;
    const actions: CodeAction[] = [];

    Logger.debug(`CodeAction: Processing ${diagnostics.length} diagnostics.`);

    for (const diagnostic of diagnostics) {
        if (diagnostic.message.includes("Missing 'Then' in If statement")) {
            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            // Check if there is space before
            // lineText is "If x = 1 ' comment"
            // commentIndex is 9
            // lineText[8] is '1' (not space)

            // NOTE: range.end might be beyond line length if regex matched incorrectly or includes \n?
            // Diagnostics range comes from validator which does: Range.create(line, 0, line, lineLength)
            // So lineText is the full line content.

            const prevChar =
                commentIndex !== -1 ? lineText[commentIndex - 1] : lineText[lineText.length - 1];
            const needsSpace = prevChar !== ' ';

            // If there is a comment, we want " Then ".
            // If it is end of line, we want " Then".

            let insertText = 'Then';
            if (needsSpace) {
                insertText = ' ' + insertText;
            }
            if (commentIndex !== -1) {
                insertText = insertText + ' ';
            }

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, insertText)]
                }
            };

            const action = {
                title: "Add 'Then'",
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Add 'Then'" at line ${range.start.line}`);
        } else if (diagnostic.message.includes('Variable declaration without type')) {
            // Range is the line. regex was `Dim x`.
            // We want to append " As Object" (default safe type)
            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            // Append " As Object"
            // Check whitespace
            let prefix = ' ';
            if (commentIndex !== -1) {
                if (lineText[commentIndex - 1] === ' ') prefix = '';
            } else {
                if (lineText.endsWith(' ')) prefix = '';
            }

            const textToInsert = prefix + 'As Object';

            // If inserting before comment, maybe add space after?
            // "Dim x 'comment" -> "Dim x As Object 'comment"
            const suffix = commentIndex !== -1 && lineText[commentIndex - 1] !== ' ' ? ' ' : '';

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, textToInsert + suffix)]
                }
            };

            const action = {
                title: "Add 'As Object'",
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Add 'As Object'" at line ${range.start.line}`);
        } else if (diagnostic.message.includes('missing a return type') || diagnostic.message.includes('missing type after')) {
            // "Function 'Foo' is missing a return type"
            // We want to append " As Object" after the function name/parens.
            // But validation logic checked the line.
            // If it's a multiline definition, this might be tricky.
            // Assuming single line or ends on this line.

            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            // Append " As Object"
            let textToInsert = ' As Object';

            // Check if line already ends with " As" (missing type case)
            if (/\bAs\s*$/i.test(lineText.substring(0, commentIndex === -1 ? undefined : commentIndex).trimEnd())) {
                textToInsert = ' Object';
            }

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, textToInsert)]
                }
            };

            const action = {
                title: "Add 'As Object'",
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Add 'As Object' (Return Type)" at line ${range.start.line}`);
        } else if (diagnostic.message.includes('Avoid magic numbers')) {
            // "Avoid magic numbers (100). Use a Constant instead."
            const match = /magic numbers \((\d+)\)/.exec(diagnostic.message);
            if (match) {
                const value = match[1];
                const constName = `CONST_${value}`; // Simple generation strategy

                // Find where to insert: Start of the containing method/block?
                const symbols = parseDocumentSymbols(document);
                const container = getSymbolContainingPosition(symbols, diagnostic.range.start);

                let insertPos = { line: 0, character: 0 };
                let indentation = '';

                if (container) {
                    // Insert at start of container (after definition)
                    // container.range.start is the definition line.
                    // We want to insert after that line.
                    insertPos = { line: container.range.start.line + 1, character: 0 };

                    // Try to match indentation of the container's content?
                    // Usually indentation of container + 1 level?
                    // Or just use 4 spaces/1 tab.
                    // Let's assume standard indentation.
                    indentation = '\t';
                }

                const constDecl = `${indentation}Const ${constName} = ${value}\n`;

                const edit: WorkspaceEdit = {
                    changes: {
                        [document.uri]: [
                            TextEdit.insert(insertPos, constDecl),
                            TextEdit.replace(diagnostic.range, constName)
                        ]
                    }
                };

                const action = {
                    title: 'Extract to Constant',
                    kind: CodeActionKind.RefactorExtract,
                    diagnostics: [diagnostic],
                    edit: edit
                };
                actions.push(action);
                Logger.debug(`CodeAction: Proposed "Extract to Constant" for ${value}`);
            }
        } else if (diagnostic.message.includes('Const declaration requires a value')) {
            // Range is line. regex `Const x`.
            // Append " = 0"
            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            const textToInsert = ' = 0';

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, textToInsert)]
                }
            };

            const action = {
                title: 'Initialize with 0',
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Initialize with 0" at line ${range.start.line}`);
        } else if (diagnostic.message.includes('Missing closing statement for')) {
            const match = /Missing closing statement for '(\w+)'/.exec(diagnostic.message);
            if (match) {
                const blockType = match[1];
                const closeStmt = getClosingStatement(blockType);

                // Insert at end of document
                const lastLine = document.lineCount;
                const insertPos = { line: lastLine, character: 0 };

                const action = {
                    title: `Add '${closeStmt}'`,
                    kind: CodeActionKind.QuickFix,
                    diagnostics: [diagnostic],
                    edit: {
                        changes: {
                            [document.uri]: [TextEdit.insert(insertPos, '\n' + closeStmt)]
                        }
                    }
                };
                actions.push(action);
                Logger.debug(`CodeAction: Proposed "Add '${closeStmt}'" at end of document`);
            }
        } else if (diagnostic.message.includes('Mismatched block')) {
            const match = /Expected closing for '(\w+)'/.exec(diagnostic.message);
            if (match) {
                const blockType = match[1];
                const closeStmt = getClosingStatement(blockType);

                // Insert before the mismatch line
                const insertPos = { line: diagnostic.range.start.line, character: 0 };

                const action = {
                    title: `Add '${closeStmt}'`,
                    kind: CodeActionKind.QuickFix,
                    diagnostics: [diagnostic],
                    edit: {
                        changes: {
                            [document.uri]: [TextEdit.insert(insertPos, closeStmt + '\n')]
                        }
                    }
                };
                actions.push(action);
                Logger.debug(`CodeAction: Proposed "Add '${closeStmt}'" at line ${insertPos.line}`);
            }
        } else if (diagnostic.message.includes('is declared but never used')) {
            // Unused variable diagnostic
            // Range is the selectionRange (just the name)
            // But validation.ts reports it on `sym.selectionRange`.
            // Ideally we want to remove the whole line if it's "Dim x As Integer".
            // But what if it is "Dim x, y As Integer"?
            // If we assume "Dim x As Integer" (standard), we can check the line content.

            const range = diagnostic.range;
            const lineText = document.getText({
                start: { line: range.start.line, character: 0 },
                end: { line: range.start.line + 1, character: 0 }
            }); // Get full line with newline

            // Check if line contains only this declaration
            // Regex to match "Dim <name> [As Type] ['Comment]"
            // We just check if there are other statements.
            // If the line is trimmed and starts with Dim and the variable is unused...
            // It's safer to just remove the range provided by diagnostic?
            // No, that's just the name 'x'. Removing 'x' leaves "Dim  As Integer". Bad.

            // Let's rely on finding the "Dim ... " statement that contains this range.
            // Simplified: If the line contains "Dim <name>" and nothing else (ignoring type and comments), remove line.

            const trimmed = lineText.trim();
            // Ensure no other statements on the same line (no ':')
            // Ensure no initialization (no '=') to avoid removing side-effects (e.g., Dim x = CallFunc())
            // Ensure no multiple declarations (no ',')
            if (
                !trimmed.includes(':') &&
                !trimmed.includes('=') &&
                !trimmed.includes(',') &&
                trimmed.toLowerCase().startsWith('dim')
            ) {
                // Remove whole line
                const action = {
                    title: 'Remove unused variable',
                    kind: CodeActionKind.QuickFix,
                    diagnostics: [diagnostic],
                    edit: {
                        changes: {
                            [document.uri]: [
                                TextEdit.del({
                                    start: { line: range.start.line, character: 0 },
                                    end: { line: range.start.line + 1, character: 0 }
                                })
                            ]
                        }
                    }
                };
                actions.push(action);
            }
        }
    }

    Logger.debug(`CodeAction: Returning ${actions.length} actions.`);
    return actions;
}

/**
 * Returns the correct closing statement for a given block type.
 *
 * @param type The block type (e.g., "If", "For").
 * @returns The closing statement (e.g., "End If", "Next").
 */
function getClosingStatement(type: string): string {
    switch (type.toLowerCase()) {
        case 'if':
            return 'End If';
        case 'select':
            return 'End Select';
        case 'for':
            return 'Next';
        case 'do':
            return 'Loop';
        case 'while':
            return 'Wend';
        case 'sub':
            return 'End Sub';
        case 'function':
            return 'End Function';
        case 'class':
            return 'End Class';
        case 'module':
            return 'End Module';
        case 'property':
            return 'End Property';
        default:
            return 'End ' + type;
    }
}
