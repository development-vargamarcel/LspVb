import {
    CodeAction,
    CodeActionKind,
    CodeActionParams,
    Command,
    TextEdit,
    WorkspaceEdit,
    SymbolKind,
    DocumentSymbol
} from 'vscode-languageserver/node';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { Logger } from '../utils/logger';
import { parseDocumentSymbols, getSymbolContainingPosition } from '../utils/parser';
import { stripComment } from '../utils/textUtils';

/**
 * Handles code action requests.
 * Provides Quick Fixes for diagnostics generated by the validator.
 *
 * @param params The code action parameters.
 * @param document The text document.
 * @returns An array of CodeActions or Commands.
 */
// Mapping of common types to their namespaces for "Add Imports"
const COMMON_IMPORTS: Record<string, string> = {
    'List': 'System.Collections.Generic',
    'Dictionary': 'System.Collections.Generic',
    'HashSet': 'System.Collections.Generic',
    'Queue': 'System.Collections.Generic',
    'Stack': 'System.Collections.Generic',
    'File': 'System.IO',
    'Directory': 'System.IO',
    'Path': 'System.IO',
    'Stream': 'System.IO',
    'StreamReader': 'System.IO',
    'StreamWriter': 'System.IO',
    'StringBuilder': 'System.Text',
    'Regex': 'System.Text.RegularExpressions',
    'Task': 'System.Threading.Tasks',
    'Thread': 'System.Threading'
};

export function onCodeAction(
    params: CodeActionParams,
    document: TextDocument
): (Command | CodeAction)[] {
    Logger.log('Code actions requested for ' + document.uri);
    const diagnostics = params.context.diagnostics;
    const actions: CodeAction[] = [];

    Logger.debug(`CodeAction: Processing ${diagnostics.length} diagnostics.`);

    for (const diagnostic of diagnostics) {
        if (diagnostic.message.includes("Type '") && diagnostic.message.includes("' is not defined")) {
            // "Type 'List' is not defined."
            const match = /Type '([^']+)' is not defined/.exec(diagnostic.message);
            if (match) {
                const typeName = match[1];
                // Handle generics e.g. List(Of T) -> List
                const baseType = typeName.split('(')[0].trim();
                const importNamespace = COMMON_IMPORTS[baseType];

                if (importNamespace) {
                    const action: CodeAction = {
                        title: `Import '${importNamespace}'`,
                        kind: CodeActionKind.QuickFix,
                        diagnostics: [diagnostic],
                        edit: {
                            changes: {
                                [document.uri]: [
                                    TextEdit.insert({ line: 0, character: 0 }, `Imports ${importNamespace}\n`)
                                ]
                            }
                        }
                    };
                    actions.push(action);
                    Logger.debug(`CodeAction: Proposed "Import ${importNamespace}" for ${baseType}`);
                }
            }
        }

        if (diagnostic.message.includes("Missing 'Then' in If statement")) {
            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            // Check if there is space before
            // lineText is "If x = 1 ' comment"
            // commentIndex is 9
            // lineText[8] is '1' (not space)

            // NOTE: range.end might be beyond line length if regex matched incorrectly or includes \n?
            // Diagnostics range comes from validator which does: Range.create(line, 0, line, lineLength)
            // So lineText is the full line content.

            const prevChar =
                commentIndex !== -1 ? lineText[commentIndex - 1] : lineText[lineText.length - 1];
            const needsSpace = prevChar !== ' ';

            // If there is a comment, we want " Then ".
            // If it is end of line, we want " Then".

            let insertText = 'Then';
            if (needsSpace) {
                insertText = ' ' + insertText;
            }
            if (commentIndex !== -1) {
                insertText = insertText + ' ';
            }

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, insertText)]
                }
            };

            const action = {
                title: "Add 'Then'",
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Add 'Then'" at line ${range.start.line}`);
        } else if (diagnostic.message.includes('Variable declaration without type')) {
            // Range is the line. regex was `Dim x`.
            // We want to append " As Object" (default safe type)
            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            // Append " As Object"
            // Check whitespace
            let prefix = ' ';
            if (commentIndex !== -1) {
                if (lineText[commentIndex - 1] === ' ') prefix = '';
            } else {
                if (lineText.endsWith(' ')) prefix = '';
            }

            const textToInsert = prefix + 'As Object';

            // If inserting before comment, maybe add space after?
            // "Dim x 'comment" -> "Dim x As Object 'comment"
            const suffix = commentIndex !== -1 && lineText[commentIndex - 1] !== ' ' ? ' ' : '';

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, textToInsert + suffix)]
                }
            };

            const action = {
                title: "Add 'As Object'",
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Add 'As Object'" at line ${range.start.line}`);
        } else if (
            diagnostic.message.includes('missing a return type') ||
            diagnostic.message.includes('missing type after')
        ) {
            // "Function 'Foo' is missing a return type"
            // We want to append " As Object" after the function name/parens.
            // But validation logic checked the line.
            // If it's a multiline definition, this might be tricky.
            // Assuming single line or ends on this line.

            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            // Append " As Object"
            let textToInsert = ' As Object';

            // Check if line already ends with " As" (missing type case)
            if (
                /\bAs\s*$/i.test(
                    lineText.substring(0, commentIndex === -1 ? undefined : commentIndex).trimEnd()
                )
            ) {
                textToInsert = ' Object';
            }

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, textToInsert)]
                }
            };

            const action = {
                title: "Add 'As Object'",
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(
                `CodeAction: Proposed "Add 'As Object' (Return Type)" at line ${range.start.line}`
            );
        } else if (diagnostic.message.includes('Avoid magic numbers')) {
            // "Avoid magic numbers (100). Use a Constant instead."
            const match = /magic numbers \((\d+)\)/.exec(diagnostic.message);
            if (match) {
                const value = match[1];
                const constName = `CONST_${value}`; // Simple generation strategy

                // Find where to insert: Start of the containing method/block?
                const symbols = parseDocumentSymbols(document);
                const container = getSymbolContainingPosition(symbols, diagnostic.range.start);

                let insertPos = { line: 0, character: 0 };
                let indentation = '';

                if (container) {
                    // Insert at start of container (after definition)
                    // container.range.start is the definition line.
                    // We want to insert after that line.
                    insertPos = { line: container.range.start.line + 1, character: 0 };

                    // Try to match indentation of the container's content?
                    // Usually indentation of container + 1 level?
                    // Or just use 4 spaces/1 tab.
                    // Let's assume standard indentation.
                    indentation = '\t';
                }

                const constDecl = `${indentation}Const ${constName} = ${value}\n`;

                const edit: WorkspaceEdit = {
                    changes: {
                        [document.uri]: [
                            TextEdit.insert(insertPos, constDecl),
                            TextEdit.replace(diagnostic.range, constName)
                        ]
                    }
                };

                const action = {
                    title: 'Extract to Constant',
                    kind: CodeActionKind.RefactorExtract,
                    diagnostics: [diagnostic],
                    edit: edit
                };
                actions.push(action);
                Logger.debug(`CodeAction: Proposed "Extract to Constant" for ${value}`);
            }
        } else if (diagnostic.message.includes('Const declaration requires a value')) {
            // Range is line. regex `Const x`.
            // Append " = 0"
            const range = diagnostic.range;
            const lineText = document.getText(range);
            const commentIndex = lineText.indexOf("'");
            let insertPos = range.end;

            if (commentIndex !== -1) {
                insertPos = { line: range.start.line, character: commentIndex };
            }

            const textToInsert = ' = 0';

            const edit: WorkspaceEdit = {
                changes: {
                    [document.uri]: [TextEdit.insert(insertPos, textToInsert)]
                }
            };

            const action = {
                title: 'Initialize with 0',
                kind: CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                edit: edit
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Initialize with 0" at line ${range.start.line}`);
        } else if (diagnostic.message.includes('Missing closing statement for')) {
            const match = /Missing closing statement for '(\w+)'/.exec(diagnostic.message);
            if (match) {
                const blockType = match[1];
                const closeStmt = getClosingStatement(blockType);

                // Insert at end of document
                const lastLine = document.lineCount;
                const insertPos = { line: lastLine, character: 0 };

                const action = {
                    title: `Add '${closeStmt}'`,
                    kind: CodeActionKind.QuickFix,
                    diagnostics: [diagnostic],
                    edit: {
                        changes: {
                            [document.uri]: [TextEdit.insert(insertPos, '\n' + closeStmt)]
                        }
                    }
                };
                actions.push(action);
                Logger.debug(`CodeAction: Proposed "Add '${closeStmt}'" at end of document`);
            }
        } else if (diagnostic.message.includes('Mismatched block')) {
            const match = /Expected closing for '(\w+)'/.exec(diagnostic.message);
            if (match) {
                const blockType = match[1];
                const closeStmt = getClosingStatement(blockType);

                // Insert before the mismatch line
                const insertPos = { line: diagnostic.range.start.line, character: 0 };

                const action = {
                    title: `Add '${closeStmt}'`,
                    kind: CodeActionKind.QuickFix,
                    diagnostics: [diagnostic],
                    edit: {
                        changes: {
                            [document.uri]: [TextEdit.insert(insertPos, closeStmt + '\n')]
                        }
                    }
                };
                actions.push(action);
                Logger.debug(`CodeAction: Proposed "Add '${closeStmt}'" at line ${insertPos.line}`);
            }
        } else if (diagnostic.message.includes('must implement member')) {
            const data = diagnostic.data as any;
            if (data && data.missingMember && data.interfaceName) {
                const memberName = data.missingMember;
                const interfaceName = data.interfaceName;
                const kind = data.memberKind;
                const detail = data.memberDetail;

                // Parse document symbols to find the class end position
                const symbols = parseDocumentSymbols(document);
                const classSymbol = getSymbolContainingPosition(symbols, diagnostic.range.start);

                if (classSymbol) {
                    // Determine indentation
                    const classLine = document.getText({
                        start: { line: classSymbol.range.start.line, character: 0 },
                        end: { line: classSymbol.range.start.line + 1, character: 0 }
                    });
                    const matchIndent = classLine.match(/^(\s*)/);
                    const classIndent = matchIndent ? matchIndent[1] : '';
                    const memberIndent = classIndent + (classIndent.includes('\t') ? '\t' : '    ');
                    const bodyIndent = memberIndent + (classIndent.includes('\t') ? '\t' : '    ');

                    let stub = '';

                    if (kind === SymbolKind.Method) {
                        let decl = detail || `Sub ${memberName}()`;
                        // Ensure decl starts with Sub/Function
                        if (!/^(Sub|Function)/i.test(decl)) decl = `Sub ${memberName}()`;

                        stub = [
                            '',
                            `${memberIndent}Public ${decl} Implements ${interfaceName}.${memberName}`,
                            `${bodyIndent}Throw New NotImplementedException()`,
                            `${memberIndent}End Sub`,
                            ''
                        ].join('\n');
                    } else if (kind === SymbolKind.Function) {
                        let decl = detail || `Function ${memberName}() As Object`;
                        if (!/^(Sub|Function)/i.test(decl)) decl = `Function ${memberName}() As Object`;

                        stub = [
                            '',
                            `${memberIndent}Public ${decl} Implements ${interfaceName}.${memberName}`,
                            `${bodyIndent}Throw New NotImplementedException()`,
                            `${bodyIndent}Return Nothing`,
                            `${memberIndent}End Function`,
                            ''
                        ].join('\n');
                    } else if (kind === SymbolKind.Property) {
                        let decl = detail || `Property ${memberName}() As Object`;
                        if (!/^Property/i.test(decl)) decl = `Property ${memberName}() As Object`;

                        stub = [
                            '',
                            `${memberIndent}Public ${decl} Implements ${interfaceName}.${memberName}`,
                            `${bodyIndent}Get`,
                            `${bodyIndent}    Throw New NotImplementedException()`,
                            `${bodyIndent}End Get`,
                            `${bodyIndent}Set(value)`,
                            `${bodyIndent}    Throw New NotImplementedException()`,
                            `${bodyIndent}End Set`,
                            `${memberIndent}End Property`,
                            ''
                        ].join('\n');
                    }

                    if (stub) {
                        // Insert at the end of the class (before End Class)
                        const insertPos = { line: classSymbol.range.end.line, character: 0 };

                        const action: CodeAction = {
                            title: `Implement '${memberName}'`,
                            kind: CodeActionKind.QuickFix,
                            diagnostics: [diagnostic],
                            edit: {
                                changes: {
                                    [document.uri]: [TextEdit.insert(insertPos, stub)]
                                }
                            }
                        };
                        actions.push(action);
                        Logger.debug(`CodeAction: Proposed "Implement Interface Member" for ${memberName}`);
                    }
                }
            }
        } else if (diagnostic.message.includes('is declared but never used')) {
            // Unused variable diagnostic
            // Range is the selectionRange (just the name)
            // But validation.ts reports it on `sym.selectionRange`.
            // Ideally we want to remove the whole line if it's "Dim x As Integer".
            // But what if it is "Dim x, y As Integer"?
            // If we assume "Dim x As Integer" (standard), we can check the line content.

            const range = diagnostic.range;
            const lineText = document.getText({
                start: { line: range.start.line, character: 0 },
                end: { line: range.start.line + 1, character: 0 }
            }); // Get full line with newline

            // Check if line contains only this declaration
            // Regex to match "Dim <name> [As Type] ['Comment]"
            // We just check if there are other statements.
            // If the line is trimmed and starts with Dim and the variable is unused...
            // It's safer to just remove the range provided by diagnostic?
            // No, that's just the name 'x'. Removing 'x' leaves "Dim  As Integer". Bad.

            // Let's rely on finding the "Dim ... " statement that contains this range.
            // Simplified: If the line contains "Dim <name>" and nothing else (ignoring type and comments), remove line.

            const trimmed = lineText.trim();
            // Ensure no other statements on the same line (no ':')
            // Ensure no initialization (no '=') to avoid removing side-effects (e.g., Dim x = CallFunc())

            if (
                !trimmed.includes(':') &&
                !trimmed.includes('=') &&
                trimmed.toLowerCase().startsWith('dim')
            ) {
                // Check for multiple declarations
                if (!trimmed.includes(',')) {
                    // Simple case: Single declaration. Remove whole line.
                    const action = {
                        title: 'Remove unused variable',
                        kind: CodeActionKind.QuickFix,
                        diagnostics: [diagnostic],
                        edit: {
                            changes: {
                                [document.uri]: [
                                    TextEdit.del({
                                        start: { line: range.start.line, character: 0 },
                                        end: { line: range.start.line + 1, character: 0 }
                                    })
                                ]
                            }
                        }
                    };
                    actions.push(action);
                } else {
                    // Multiple declarations: Dim x, y As Integer
                    // We need to remove the variable name and its associated comma.
                    // diagnostic.range covers just the name.

                    // We need to find where this variable is in the line to know if we remove comma before or after.
                    // Case 1: "Dim x, y" -> Remove "x, " -> "Dim y"
                    // Case 2: "Dim x, y" -> Remove ", y" -> "Dim x"
                    // Case 3: "Dim x, y, z" -> Remove ", y" -> "Dim x, z" (or "y, ")

                    // Get text before and after the range within the line
                    const startChar = range.start.character;
                    const endChar = range.end.character;

                    // Check character immediately after name (skipping whitespace)
                    let afterIndex = endChar;
                    while (afterIndex < lineText.length && /\s/.test(lineText[afterIndex])) {
                        afterIndex++;
                    }

                    let deleteRangeStart = range.start;
                    let deleteRangeEnd = range.end;

                    let commaFound = false;

                    if (afterIndex < lineText.length && lineText[afterIndex] === ',') {
                        // Comma after: Remove "Name, " (and trailing spaces)
                        deleteRangeEnd = { line: range.end.line, character: afterIndex + 1 };
                        // Consume spaces after comma too? "Dim x, y" -> remove "x, " -> "Dim y"
                        let nextStart = afterIndex + 1;
                        while (nextStart < lineText.length && /\s/.test(lineText[nextStart])) {
                            nextStart++;
                        }
                        deleteRangeEnd = { line: range.end.line, character: nextStart };
                        commaFound = true;
                    } else {
                        // Check comma before: "Dim x, y" -> Remove ", y" (and preceding spaces)
                        let beforeIndex = startChar - 1;
                        while (beforeIndex >= 0 && /\s/.test(lineText[beforeIndex])) {
                            beforeIndex--;
                        }

                        if (beforeIndex >= 0 && lineText[beforeIndex] === ',') {
                            // Comma before
                            deleteRangeStart = { line: range.start.line, character: beforeIndex };
                            commaFound = true;
                        }
                    }

                    if (commaFound) {
                        const action = {
                            title: 'Remove unused variable',
                            kind: CodeActionKind.QuickFix,
                            diagnostics: [diagnostic],
                            edit: {
                                changes: {
                                    [document.uri]: [
                                        TextEdit.del({
                                            start: deleteRangeStart,
                                            end: deleteRangeEnd
                                        })
                                    ]
                                }
                            }
                        };
                        actions.push(action);
                    }
                }
            }
        }
    }

    const range = params.range;

    // Check for "Generate Property" (Encapsulate Field)
    // Trigger only if single line or no selection (cursor)
    if (range.start.line === range.end.line) {
        const lineIndex = range.start.line;
        const lineText = document.getText({
            start: { line: lineIndex, character: 0 },
            end: { line: lineIndex + 1, character: 0 }
        });
        const trimmed = lineText.trim();

        // Regex for private field: (Private|Dim) _name As Type
        // Captures: 1=Private/Dim, 2=Name (without _), 3=Type
        const fieldMatch = /^(?:Private|Dim)\s+_(\w+)\s+As\s+([\w.]+)/i.exec(trimmed);

        if (fieldMatch) {
            const name = fieldMatch[1]; // e.g. "foo" from "_foo"
            const type = fieldMatch[2]; // e.g. "Integer"

            // Capitalize property name
            const propName = name.charAt(0).toUpperCase() + name.slice(1);

            // Indentation
            const indentationMatch = lineText.match(/^(\s*)/);
            const indentation = indentationMatch ? indentationMatch[1] : '';
            const indentUnit = indentation.includes('\t') ? '\t' : '    ';

            const propertyText = [
                `Public Property ${propName} As ${type}`,
                `${indentUnit}Get`,
                `${indentUnit}${indentUnit}Return _${name}`,
                `${indentUnit}End Get`,
                `${indentUnit}Set(value As ${type})`,
                `${indentUnit}${indentUnit}_${name} = value`,
                `${indentUnit}End Set`,
                `End Property`
            ].map((l) => indentation + l).join('\n') + '\n';

            // Insert after the field line
            const insertPos = { line: lineIndex + 1, character: 0 };

            const action: CodeAction = {
                title: `Encapsulate Field: Generate Property '${propName}'`,
                kind: CodeActionKind.Refactor,
                edit: {
                    changes: {
                        [document.uri]: [TextEdit.insert(insertPos, propertyText)]
                    }
                }
            };
            actions.push(action);
            Logger.debug(`CodeAction: Proposed "Encapsulate Field" for _${name}`);
        }
    }

    // Check for "Generate Constructor"
    // Trigger if cursor is inside a Class/Structure and no selection (or range is single line)
    if (range.start.line === range.end.line) {
        // We need symbols to check container
        // Note: This parses the document again. In a real LS, we might cache this or use a shared model.
        const symbols = parseDocumentSymbols(document);
        const container = getSymbolContainingPosition(symbols, range.start);

        if (
            container &&
            (container.kind === SymbolKind.Class || container.kind === SymbolKind.Struct)
        ) {
            // Check if constructor exists
            const hasConstructor = container.children?.some(
                (c) => c.name.toLowerCase() === 'new' && c.kind === SymbolKind.Method
            );

            if (!hasConstructor && container.children) {
                // Collect fields
                // We look for fields starting with _ (private backing fields)
                // Also check "Dim" fields if they are inside Class (treated as Private usually)

                const fields = container.children.filter(
                    (c) =>
                        (c.kind === SymbolKind.Field || c.kind === SymbolKind.Variable) &&
                        c.name.startsWith('_')
                );

                if (fields.length > 0) {
                    const args: string[] = [];
                    const assignments: string[] = [];

                    for (const field of fields) {
                        const propName = field.name.substring(1); // remove _
                        // Parse type from detail: "Private _name As Type" or "Dim _name As Type"
                        let type = 'Object';
                        const asMatch = /\bAs\s+([\w.]+)/i.exec(field.detail || '');
                        if (asMatch) {
                            type = asMatch[1];
                        }
                        args.push(`${propName} As ${type}`);
                        assignments.push(`    ${field.name} = ${propName}`);
                    }

                    // Determine indentation
                    // Container range start is the "Class Person" line.
                    // We want the indentation of that line + 1 level.
                    const containerLineText = document.getText({
                        start: { line: container.range.start.line, character: 0 },
                        end: { line: container.range.start.line + 1, character: 0 }
                    });
                    const indentationMatch = containerLineText.match(/^(\s*)/);
                    const indentation = indentationMatch ? indentationMatch[1] : '';
                    const indentUnit = indentation.includes('\t') ? '\t' : '    ';
                    const methodIndent = indentation + indentUnit;
                    const bodyIndent = methodIndent + indentUnit;

                    const argsStr = args.join(', ');
                    const assignmentsStr = assignments.map((a) => methodIndent + a).join('\n');

                    const constructorCode = [
                        '',
                        `${methodIndent}Public Sub New(${argsStr})`,
                        assignmentsStr,
                        `${methodIndent}End Sub`,
                        ''
                    ].join('\n');

                    // Insert after the last field
                    // Find the last field in the list (ordered by line ideally, but parser returns in order)
                    const lastField = fields[fields.length - 1];
                    const insertPos = { line: lastField.range.end.line + 1, character: 0 };

                    const action: CodeAction = {
                        title: `Generate Constructor`,
                        kind: CodeActionKind.Refactor,
                        edit: {
                            changes: {
                                [document.uri]: [TextEdit.insert(insertPos, constructorCode)]
                            }
                        }
                    };
                    actions.push(action);
                    Logger.debug(`CodeAction: Proposed "Generate Constructor" with ${args.length} parameters`);
                }
            }
        }
    }

    // Check for "Generate ToString", "Equals", "GetHashCode"
    if (range.start.line === range.end.line) {
        const symbols = parseDocumentSymbols(document);
        const container = getSymbolContainingPosition(symbols, range.start);

        if (
            container &&
            (container.kind === SymbolKind.Class || container.kind === SymbolKind.Struct)
        ) {
            const members =
                container.children?.filter(
                    (c) => c.kind === SymbolKind.Field || c.kind === SymbolKind.Property
                ) || [];

            // Generate ToString
            const hasToString = container.children?.some(
                (c) =>
                    c.name.toLowerCase() === 'tostring' &&
                    (c.kind === SymbolKind.Method || c.kind === SymbolKind.Function)
            );

            if (!hasToString && members.length > 0) {
                // Indentation
                const containerLineText = document.getText({
                    start: { line: container.range.start.line, character: 0 },
                    end: { line: container.range.start.line + 1, character: 0 }
                });
                const indentationMatch = containerLineText.match(/^(\s*)/);
                const indentation = indentationMatch ? indentationMatch[1] : '';
                const indentUnit = indentation.includes('\t') ? '\t' : '    ';
                const methodIndent = indentation + indentUnit;
                const bodyIndent = methodIndent + indentUnit;

                const concatParts = members
                    .map((m) => `"${m.name}=" & ${m.name}`)
                    .join(' & ", " & ');
                const toStringCode = [
                    '',
                    `${methodIndent}Public Overrides Function ToString() As String`,
                    `${bodyIndent}Return "${container.name} [" & ${concatParts} & "]"`,
                    `${methodIndent}End Function`,
                    ''
                ].join('\n');

                // Insert at end of class (before End Class)
                const insertPos = { line: container.range.end.line, character: 0 };

                actions.push({
                    title: 'Generate ToString',
                    kind: CodeActionKind.Refactor,
                    edit: {
                        changes: {
                            [document.uri]: [TextEdit.insert(insertPos, toStringCode)]
                        }
                    }
                });
                Logger.debug(`CodeAction: Proposed "Generate ToString"`);
            }

            // Generate Equals and GetHashCode
            const hasEquals = container.children?.some(
                (c) =>
                    c.name.toLowerCase() === 'equals' &&
                    (c.kind === SymbolKind.Method || c.kind === SymbolKind.Function)
            );
            const hasGetHashCode = container.children?.some(
                (c) =>
                    c.name.toLowerCase() === 'gethashcode' &&
                    (c.kind === SymbolKind.Method || c.kind === SymbolKind.Function)
            );

            if (!hasEquals && !hasGetHashCode && members.length > 0) {
                // Indentation (reuse)
                const containerLineText = document.getText({
                    start: { line: container.range.start.line, character: 0 },
                    end: { line: container.range.start.line + 1, character: 0 }
                });
                const indentationMatch = containerLineText.match(/^(\s*)/);
                const indentation = indentationMatch ? indentationMatch[1] : '';
                const indentUnit = indentation.includes('\t') ? '\t' : '    ';
                const methodIndent = indentation + indentUnit;
                const bodyIndent = methodIndent + indentUnit;

                // Equals
                const equalsChecks = members
                    .map((m) => `Me.${m.name} = other.${m.name}`)
                    .join(' AndAlso ');

                // GetHashCode
                // Simple hash combination
                const hashLines = members.map(
                    (m) =>
                        `${bodyIndent}hash = (hash * 23) + (If(Me.${m.name} IsNot Nothing, Me.${m.name}.GetHashCode(), 0))`
                );

                const code = [
                    '',
                    `${methodIndent}Public Overrides Function Equals(obj As Object) As Boolean`,
                    `${bodyIndent}If obj Is Nothing OrElse Not Me.GetType() Is obj.GetType() Then`,
                    `${bodyIndent}${indentUnit}Return False`,
                    `${bodyIndent}End If`,
                    `${bodyIndent}Dim other = CType(obj, ${container.name})`,
                    `${bodyIndent}Return ${equalsChecks}`,
                    `${methodIndent}End Function`,
                    '',
                    `${methodIndent}Public Overrides Function GetHashCode() As Integer`,
                    `${bodyIndent}Dim hash = 17`,
                    ...hashLines,
                    `${bodyIndent}Return hash`,
                    `${methodIndent}End Function`,
                    ''
                ].join('\n');

                const insertPos = { line: container.range.end.line, character: 0 };

                actions.push({
                    title: 'Generate Equals and GetHashCode',
                    kind: CodeActionKind.Refactor,
                    edit: {
                        changes: {
                            [document.uri]: [TextEdit.insert(insertPos, code)]
                        }
                    }
                });
                Logger.debug(`CodeAction: Proposed "Generate Equals and GetHashCode"`);
            }
        }
    }

    // Check for "Wrap in Try/Catch"
    if (range.start.line !== range.end.line || range.start.character !== range.end.character) {
        // Selection exists
        const startLine = range.start.line;
        let endLine = range.end.line;

        // Adjust end line if selection ends at column 0 of next line
        if (range.end.character === 0 && range.end.line > range.start.line) {
            endLine = range.end.line - 1;
        }

        // Expand selection to full lines
        const expandedRange = {
            start: { line: startLine, character: 0 },
            end: { line: endLine + 1, character: 0 }
        };

        const textToWrap = document.getText(expandedRange);

        // Only propose if selection is valid
        if (textToWrap.trim().length > 0) {
            // Get indentation from the first line
            const firstLine = document.getText({
                start: { line: startLine, character: 0 },
                end: { line: startLine + 1, character: 0 }
            });
            const indentationMatch = firstLine.match(/^(\s*)/);
            const indentation = indentationMatch ? indentationMatch[1] : '';

            // Detect indentation unit (tab or 4 spaces)
            const indentUnit = indentation.includes('\t') ? '\t' : '    ';

            const linesToWrap = textToWrap.split(/\r?\n/);
            // Handle split edge case: if text ends with newline, split gives empty string at end
            if (linesToWrap.length > 0 && linesToWrap[linesToWrap.length - 1] === '') {
                linesToWrap.pop();
            }

            const wrappedText = [
                `${indentation}Try`,
                ...linesToWrap.map((l) => indentUnit + l),
                `${indentation}Catch ex As Exception`,
                `${indentation}${indentUnit}' TODO: Handle exception`,
                `${indentation}End Try`,
                '' // Newline at end
            ].join('\n');

            const action: CodeAction = {
                title: 'Wrap in Try...Catch',
                kind: CodeActionKind.RefactorRewrite,
                edit: {
                    changes: {
                        [document.uri]: [TextEdit.replace(expandedRange, wrappedText)]
                    }
                }
            };
            actions.push(action);
            Logger.debug(
                `CodeAction: Proposed "Wrap in Try...Catch" for lines ${startLine}-${endLine}`
            );
        }
    }

    // Check for "Invert If"
    // Trigger if cursor is on "If" or "Else" line
    if (range.start.line === range.end.line) {
        const lineText = document.getText({
            start: { line: range.start.line, character: 0 },
            end: { line: range.start.line + 1, character: 0 }
        });
        const trimmed = lineText.trim();
        const lower = trimmed.toLowerCase();

        // Check if cursor is on If or Else line
        if (
            (lower.startsWith('if ') && lower.includes(' then')) ||
            lower === 'else' ||
            lower.startsWith('else ') // check comment
        ) {
            // Locate the full block
            // We need to scan up/down to find If/Else/End If
            // This relies on indentation or just keyword matching.
            // Using parseDocumentSymbols is safer to get the range of the whole If block.
            const symbols = parseDocumentSymbols(document);
            const ifSymbol = getSymbolContainingPosition(symbols, range.start);

            if (ifSymbol && ifSymbol.name === 'If') {
                // Now scan the lines within the symbol range to find parts
                const startLine = ifSymbol.range.start.line;
                const endLine = ifSymbol.range.end.line;

                let elseLineIndex = -1;
                let hasElseIf = false;
                let thenLineIndex = -1;

                // Find "Then" and "Else"
                for (let i = startLine; i <= endLine; i++) {
                    const line = document.getText({
                        start: { line: i, character: 0 },
                        end: { line: i + 1, character: 0 }
                    });
                    const lTrim = line.trim();
                    const lLow = lTrim.toLowerCase();

                    if (i === startLine) {
                        // Extract condition
                        // "If condition Then"
                        // Handle "If condition Then 'comment"
                    }

                    if (lLow.startsWith('elseif')) {
                        hasElseIf = true;
                        break;
                    }

                    if (lLow.startsWith('else') && !lLow.startsWith('elseif')) {
                        elseLineIndex = i;
                    }
                }

                if (!hasElseIf) {
                    // Extract parts
                    const ifLine = document.getText({
                        start: { line: startLine, character: 0 },
                        end: { line: startLine + 1, character: 0 }
                    });
                    // Strip comment to avoid regex matching "Then" inside comment
                    const ifLineClean = stripComment(ifLine);
                    const ifMatch = /^(\s*)If\s+(.+)\s+Then/i.exec(ifLineClean);

                    if (ifMatch) {
                        const indentation = ifMatch[1];
                        const condition = ifMatch[2].trim();

                        // Get Then Block
                        let thenBlockStart = startLine + 1;
                        let thenBlockEnd = elseLineIndex !== -1 ? elseLineIndex : endLine; // Exclusive of Else/End If line?
                        // Actually endLine is the line OF "End If".
                        // elseLineIndex is the line OF "Else".

                        // Extract text
                        let thenBlock = '';
                        if (thenBlockStart < thenBlockEnd) {
                            thenBlock = document.getText({
                                start: { line: thenBlockStart, character: 0 },
                                end: { line: thenBlockEnd, character: 0 }
                            });
                        }

                        // Get Else Block
                        let elseBlock = '';
                        if (elseLineIndex !== -1) {
                            const elseBlockStart = elseLineIndex + 1;
                            const elseBlockEnd = endLine;
                            if (elseBlockStart < elseBlockEnd) {
                                elseBlock = document.getText({
                                    start: { line: elseBlockStart, character: 0 },
                                    end: { line: elseBlockEnd, character: 0 }
                                });
                            }
                        }

                        // Negate condition
                        const negatedCondition = negateCondition(condition);

                        // Construct new text
                        // Trim blocks to check if they have content?
                        // But usually we want to preserve internal formatting.
                        // We just need to ensure we don't add extra newlines around Else.
                        // elseBlock and thenBlock likely contain trailing newlines if obtained via getText with full lines.

                        // Remove trailing newlines from blocks if we are re-assembling?
                        // getText(range) includes newlines.

                        const newText = [
                            `${indentation}If ${negatedCondition} Then`,
                            elseBlock.trimEnd(),
                            `${indentation}Else`,
                            thenBlock.trimEnd(),
                            `${indentation}End If`
                        ].join('\n') + '\n';

                        // Handle empty Else block case (Invert If with no Else -> If Not cond Then ... End If)
                        // If originally no Else, then elseBlock is empty.
                        // Result: If Not cond Then [empty] Else [original then] End If.
                        // This is technically correct invert, but maybe we want to remove empty Else?
                        // "Invert If" implies swapping.
                        // Users often use it to introduce a guard clause or handle the negative case first.

                        // If the resulting 'Then' block is empty (original Else was empty/non-existent),
                        // we might want to keep it empty or put a comment?
                        // Or just let it be.

                        // Replace the whole block
                        const edit: WorkspaceEdit = {
                            changes: {
                                [document.uri]: [
                                    TextEdit.replace(
                                        {
                                            start: { line: startLine, character: 0 },
                                            end: { line: endLine + 1, character: 0 }
                                        },
                                        newText
                                    )
                                ]
                            }
                        };

                        const action: CodeAction = {
                            title: 'Invert If',
                            kind: CodeActionKind.RefactorRewrite,
                            edit: edit
                        };
                        actions.push(action);
                        Logger.debug(`CodeAction: Proposed "Invert If"`);
                    }
                }
            }
        }
    }

    // Check for SourceOrganizeImports
    // We also provide it if no specific kind is requested, or if Source is requested
    if (
        !params.context.only ||
        params.context.only.includes(CodeActionKind.SourceOrganizeImports) ||
        params.context.only.includes(CodeActionKind.Source)
    ) {
        const text = document.getText();
        const lines = text.split(/\r?\n/);
        const importGroups: { start: number; end: number; lines: string[] }[] = [];

        let currentGroup: { start: number; end: number; lines: string[] } | null = null;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmed = line.trim();
            if (trimmed.toLowerCase().startsWith('imports ')) {
                if (!currentGroup) {
                    currentGroup = { start: i, end: i, lines: [line] };
                } else {
                    currentGroup.end = i;
                    currentGroup.lines.push(line);
                }
            } else {
                if (currentGroup) {
                    importGroups.push(currentGroup);
                    currentGroup = null;
                }
            }
        }
        if (currentGroup) {
            importGroups.push(currentGroup);
        }

        if (importGroups.length > 0) {
            const edits: TextEdit[] = [];
            for (const group of importGroups) {
                const originalText = group.lines.join('\n');

                // Sort lines
                const sorted = [...group.lines].sort((a, b) => {
                    const impA = a.trim().substring(8).trim(); // Remove "Imports "
                    const impB = b.trim().substring(8).trim();
                    // System.* first?
                    const isSystemA = impA.toLowerCase().startsWith('system');
                    const isSystemB = impB.toLowerCase().startsWith('system');

                    if (isSystemA && !isSystemB) return -1;
                    if (!isSystemA && isSystemB) return 1;

                    return impA.localeCompare(impB);
                });

                const newText = sorted.join('\n');

                if (newText !== originalText) {
                    // Replace range
                    // Use lines[group.end].length for end character
                    edits.push(
                        TextEdit.replace(
                            {
                                start: { line: group.start, character: 0 },
                                end: { line: group.end, character: lines[group.end].length }
                            },
                            newText
                        )
                    );
                }
            }

            if (edits.length > 0) {
                const action: CodeAction = {
                    title: 'Sort Imports',
                    kind: CodeActionKind.SourceOrganizeImports,
                    edit: {
                        changes: {
                            [document.uri]: edits
                        }
                    }
                };
                actions.push(action);
                Logger.debug(`CodeAction: Proposed "Sort Imports"`);
            }
        }
    }

    Logger.debug(`CodeAction: Returning ${actions.length} actions.`);
    return actions;
}

/**
 * Returns the correct closing statement for a given block type.
 *
 * @param type The block type (e.g., "If", "For").
 * @returns The closing statement (e.g., "End If", "Next").
 */
function getClosingStatement(type: string): string {
    switch (type.toLowerCase()) {
        case 'if':
            return 'End If';
        case 'select':
            return 'End Select';
        case 'for':
            return 'Next';
        case 'do':
            return 'Loop';
        case 'while':
            return 'Wend';
        case 'sub':
            return 'End Sub';
        case 'function':
            return 'End Function';
        case 'class':
            return 'End Class';
        case 'module':
            return 'End Module';
        case 'property':
            return 'End Property';
        default:
            return 'End ' + type;
    }
}

/**
 * Negates a VB conditional expression.
 *
 * @param condition The condition string.
 * @returns The negated condition.
 */
function negateCondition(condition: string): string {
    const trimmed = condition.trim();
    const lower = trimmed.toLowerCase();

    // Helper to check for balanced outer parentheses
    const hasBalancedOuterParens = (str: string): boolean => {
        if (!str.startsWith('(') || !str.endsWith(')')) return false;
        let depth = 0;
        for (let i = 0; i < str.length; i++) {
            if (str[i] === '(') depth++;
            else if (str[i] === ')') depth--;
            if (depth === 0 && i < str.length - 1) return false;
        }
        return depth === 0;
    };

    // Simplify common cases: Not (...)
    if (lower.startsWith('not ') && lower.indexOf('(') === 4) {
        // Not (...) -> Remove Not and outer parens?
        const inner = trimmed.substring(4).trim();
        // Verify inner has balanced outer parens (e.g. "Not (A) Or (B)" -> inner "(A) Or (B)" is NOT balanced)
        if (hasBalancedOuterParens(inner)) {
            return inner.substring(1, inner.length - 1);
        }
    }

    // If condition contains logical operators (And, Or, Xor, AndAlso, OrElse),
    // simply wrap in Not(...) to be safe.
    if (
        /\b(and|or|xor|andalso|orelse)\b/i.test(trimmed)
    ) {
         if (hasBalancedOuterParens(trimmed)) {
            return `Not ${trimmed}`;
        }
        return `Not (${trimmed})`;
    }

    // Comparison operators
    // Be careful with strings and complex expressions.
    // Simple check: single operator
    const ops = [
        { op: '=', neg: '<>' },
        { op: '<>', neg: '=' },
        { op: '>', neg: '<=' },
        { op: '<', neg: '>=' },
        { op: '>=', neg: '<' },
        { op: '<=', neg: '>' },
        { op: ' Is ', neg: ' IsNot ' },
        { op: ' IsNot ', neg: ' Is ' }
    ];

    for (const { op, neg } of ops) {
        // Use split to count occurrences. If > 2 parts, it means 1 operator.
        // Also check if inside quotes.
        const parts = trimmed.split(op);
        if (parts.length === 2) {
            return `${parts[0].trim()} ${neg.trim()} ${parts[1].trim()}`;
        }
    }

    // Default: Wrap in Not (...)
    if (hasBalancedOuterParens(trimmed)) {
        return `Not ${trimmed}`;
    }
    return `Not (${trimmed})`;
}
